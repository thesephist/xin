; vec standard library

(: (head v)
   (vec::get v 0))

(: (tail v)
   (vec::slice v 1 (vec::size v)))

(: (last v)
   (vec::get v (- (vec::size v) 1)))

(: (empty? v)
   (= (vec::size v) 0))

(: (eq? v w)
   (if (= (vec::size v) (vec::size w))
     (reduce v
             (: (f x acc i)
                (& acc (= x (vec::get w i))))
             true)
     false))

(: (reverse v)
   (if (empty? v)
     (vec)
     (vec::add! (reverse (tail v)) (head v))))

(: (cat v w)
   (do (: (sub v w)
          (if (empty? w)
            v
            (sub (vec::add! v (head w)) (tail w))))
     (sub (clone v) w)))

(: (reduce v f acc)
   (do
     (: max (vec::size v))
     (: (sub i acc)
        (if (< i max)
          (sub (+ i 1)
               (f (vec::get v i) acc i))
          acc))
     (sub 0 acc)))

(: (each v f)
   (do
     (: max (vec::size v))
     (: (sub i)
        (if (< i max)
          (do (f (vec::get v i) i)
            (sub (+ i 1)))
          0))
     (sub 0)))

(: (map v f)
   (reduce v
           (: (g x acc i)
              (vec::add! acc (f x i)))
           (vec)))

; the fastest way to clone a xin vec
; is to use the native vec::slice
(: (clone v)
   (vec::slice v 0 (vec::size v)))

(: (filter v f)
   (reduce v
           (: (g x acc i)
              (if (f x i)
                (vec::add! acc x)
                acc))
           (vec)))

; quicksort using hoare partition
(: (sort-by v pred)
   (do (: v-pred (map v pred))
     (: (swap! i j)
        (do
          (: tmp (vec::get v i))
          (: tmp-pred (vec::get v-pred i))
          (vec::set! v i (vec::get v j))
          (vec::set! v j tmp)
          (vec::set! v-pred i (vec::get v-pred j))
          (vec::set! v-pred j tmp-pred)))
     (: (partition v lo hi)
        (do (: pivot (vec::get v-pred lo))
          (: (lsub i)
             (if (>= (vec::get v-pred i) pivot)
               i (lsub (+ i 1))))
          (: (rsub j)
             (if (<= (vec::get v-pred j) pivot)
               j (rsub (- j 1))))
          (: (sub i j)
             (do
               (: i (lsub i))
               (: j (rsub j))
               (if (>= i j)
                 j
                 (do (swap! i j)
                   (sub (+ i 1) (- j 1))))))
          (sub lo hi)))
     (: (quicksort v lo hi)
        (if (empty? v)
          v
          (if (< lo hi)
            (do (: p (partition v lo hi))
              (quicksort v lo p)
              (quicksort v (+ p 1) hi))
            v)))
     (quicksort v 0 (- (vec::size v) 1))))

(: (sort! v)
   (sort-by v identity))
(: (sort v)
   (sort! (clone v)))

; building blocks to allow us to compose vector ops
(: (compose op)
   (: (? v w)
      (reduce v
              (: (f x acc i)
                 (vec::add! acc (op x (vec::get w i))))
              (vec))))

; vec of size n with elements of x
(: (of n x)
   (map (seq n) (: (f) x)))

; accumulator functions
(: std::max max)
(: (max v)
   (if (empty? v)
     0
     (reduce v std::max (head v))))
(: std::min min)
(: (min v)
   (if (empty? v)
     0
     (reduce v std::min (head v))))
(: (sum v)
   (reduce v + 0))
(: (prod v)
   (reduce v * 1))

; elementwise operators
(: ++ (compose +))
(: -- (compose -))
(: ** (compose *))
(: // (compose /))

; scalar operators
(: (v+ v s)
   (++ v (of (vec:size v) s)))
(: (v- v s)
   (-- v (of (vec:size v) s)))
(: (v* v s)
   (** v (of (vec:size v) s)))
(: (v/ v s)
   (// v (of (vec:size v) s)))

; dot and cross products, other combinators
(: (flat v)
   (reduce v (: (f w acc) (cat acc w)) (vec)))
(: (dot v w)
   (sum (** v w)))
(: (combine v w op)
   (map (flat (of (vec:size w) v))
        (: (f x i)
           (op x (vec::get w (/ i (vec:size w)))))))
