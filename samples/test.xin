; xin test suite

(: scope test::scope)
(: case test::case)
(: assert test::assert)
(: assert-false test::assert-false)
(: eq test::assert-eq)

(scope
  'Arithmetic'
  (vec
    (case 'Add two numbers'
      (eq (+ 1 1) 2))
    (case 'Subtract numbers'
      (eq (- 10 2) (- 6 -2)))
    (case 'Multiply numbers'
      (eq (* 10 2) (* 4 5)))
    (case 'Integer division'
      (eq (/ 15 4) 3))
    (case 'Fractional division'
      (eq (/ 15.0 4) 3.75))
    (case 'Power'
      (eq (^ 10 2) 100))
    (case 'Modulus'
      (eq (% 100 17) 15))
    (case 'Negative modulus'
      (eq (% -10 3) -1))))

(scope
  'Std'
  (vec
    (case 'Factor verification'
      (assert (factor? 12 4)))
    (case 'Factor verification, false'
      (assert-false (factor? 12 5)))
    (case 'Max comparison'
      (eq (max 10 -2) 10))
    (case 'Min comparison'
      (eq (min 300 4) 4))
    (case 'Basic range function'
      (assert (vec::eq? (range 1 6 1) (vec 1 2 3 4 5))))
    (case 'Range with step = 2'
      (assert (vec::eq? (range 10 20 2) (vec 10 12 14 16 18))))
    (case 'Range with negative start'
      (assert (vec::eq? (range -6 6 3) (vec -6 -3 0 3))))
    (case 'seq shorthand function'
      (assert (vec::eq? (seq 10) (vec 0 1 2 3 4 5 6 7 8 9))))
    (case 'Large seq function call'
      (eq (vec::size (seq 2500)) 2500))))

(: row (vec 3 14 15 92 65 35 897))
(: (odd? x) (% x 2))
(scope
  'Vector'
  (vec
    (case 'vec::size'
      (eq (vec::size row) 7))
    (case 'vec::head'
      (eq (vec::head row) 3))
    (case 'vec::tail'
      (assert (vec::eq? (vec::tail row) (vec 14 15 92 65 35 897))))
    (case 'vec::last'
      (eq (vec::last row) 897))
    (case 'vec::empty?'
      (assert (vec::empty? (vec))))
    (case 'vec::empty? - false'
      (assert-false (vec::empty? (seq 100))))
    (case 'vec::eq?'
      (assert (vec::eq? (seq 10) (range 0 10 1))))
    (case 'vec::eq? - false'
      (assert-false (vec::eq? (seq 5) (vec 0 1 2 4 3))))
    (case 'vec::reverse'
      (assert
        (vec::eq? (vec::reverse (seq 10))
                  (vec 9 8 7 6 5 4 3 2 1 0))))
    (case 'vec::cat'
      (assert
        (vec::eq? (vec::cat (vec 1 2 3) (vec 'hi' 'hello' 'bye'))
                  (vec 1 2 3 'hi' 'hello' 'bye'))))
    (case 'vec::reduce - number sum'
      (eq (vec::reduce (seq 11) + 3) 58))
    (case 'vec::reduce - string concatenation'
      (eq (vec::reduce (vec 'hello' 'world' 'foo' 'bar') + 'start_')
          'barfooworldhellostart_'))
    (case 'vec::reverse'
      (assert (vec::eq? (vec::reverse row) (vec 897 35 65 92 15 14 3))))
    (case 'vec::cat'
      (assert
        (vec::eq? (vec::cat row (vec 1 2 3))
                  (vec 3 14 15 92 65 35 897 1 2 3))))
    (case 'vec::map'
      (assert
        (vec::eq? (vec::map row odd?)
                  (vec 1 0 1 0 1 1 1))))
    (case 'vec::filter'
      (assert
        (vec::eq? (vec::filter row odd?)
                  (vec 3 15 65 35 897))))
    (case 'vec::every true'
      (eq (vec::every (vec 1 1 1 1 1)) true))
    (case 'vec::every false'
      (eq (vec::every (vec 1 1 0 1 0)) false))
    (case 'vec::some true'
      (eq (vec::some (vec 1 1 0 1 1)) true))
    (case 'vec::some false'
      (eq (vec::some (vec 0 0 0 0 0)) false))
    (case 'vec::sort'
      (assert
        (vec::eq? (vec::sort (vec::reverse row))
                  (vec 3 14 15 35 65 92 897))))
    (case 'vec::of'
      (assert
        (vec::eq? (vec::of 5 10)
                  (vec 10 10 10 10 10))))
    (case 'vec::max'
      (eq (vec::max row) 897))
    (case 'vec::min'
      (eq (vec::min row) 3))
    (case 'vec::sum'
      (eq (vec::sum row) 1121))
    (case 'vec::prod'
      (eq (vec::prod (vec::slice row 0 4)) 57960))
    (case 'vec::++'
      (assert
        (vec::eq? (vec::++ (vec 1 2 3) (vec 90 80 70))
                  (vec 91 82 73))))
    (case 'vec::v+'
      (assert
        (vec::eq? (vec::v+ row 100)
                  (vec 103 114 115 192 165 135 997))))
    (case 'vec::flat'
      (assert
        (vec::eq? (vec::flat (vec row row row))
                  (vec::cat (vec::cat row row) row))))))

(: hello 'Hello, World!\n')
(scope
  'String'
  (vec
    (case 'str::size of blank chars'
      (eq (str::size ' \n \t') 4))
    (case 'str::size'
      (eq (str::size hello) 14))
    (case 'str::slice in bounds'
      (eq (str::slice hello 4 10) 'o, Wor'))
    (case 'str::slice OOB left'
      (eq (str::slice hello -1 3) 'Hel'))
    (case 'str::slice OOB right'
      (eq (str::slice hello 8 200) 'orld!\n'))
    (case 'str::slice OOB both sides'
      (eq (str::slice hello -20 30) hello))
    (case 'str::slice OOB flush left'
      (eq (str::slice hello -5 -1) ''))
    (case 'str::slice OOB flush right'
      (eq (str::slice hello 20 30) ''))
    (case 'str::get'
      (eq (str::get hello 5) ','))
    (case 'str::get OOB left'
      (eq (str::get hello -5) false))
    (case 'str::get OOB right'
      (eq (str::get hello 100) false))
    (case 'str::get length'
      (eq (str::get hello (str::size hello)) false))
    (case 'str::blank? on non-blank'
      (eq (str::blank? hello) false))
    (case 'str::blank? on blank'
      (eq (str::blank? '') true))
    (case 'str::enc'
      (eq (str::enc 'abc') 97))
    (case 'str::dec'
      (eq (str::dec 65) 'A'))
    (case 'str::split'
      (assert
        (vec::eq? (str::split ', scale, by, the,bay, 2020' ', ')
                  (vec '' 'scale' 'by' 'the,bay' '2020'))))
    (case 'str::replace'
      (eq (str::replace ', scale, by, , ,the,bay, 2020' ', ' '-')
          '-scale-by--,the,bay-2020'))
    (case 'str::upcase'
      (eq (str::upcase 'Scale by the Bay!')
          'SCALE BY THE BAY!'))
    (case 'str::downcase'
      (eq (str::downcase 'Scale by the Bay!')
          'scale by the bay!'))
    (case 'str::unescape'
      (eq (str::unescape '\n\thacker \'town\\\' \n')
          '\\n\\thacker \\\'town\\\\\\\' \\n'))))

(scope
  'Map'
  (vec))

(scope
  'Set'
  (vec))

(scope
  'Data serialization'
  (vec
    (case 'simple int'
      (eq (src::serialize 42) '42'))
    (case 'simple frac'
      ; (str <frac>) will return to 8 digits, so
      ; src::serialize also does. This is fine for now.
      (eq (src::serialize -3.141592) '-3.14159200'))
    (case 'simple string'
      (eq (src::serialize 'hello world') '\'hello world\''))
    (case 'escaped string'
      (eq (src::serialize 'hello\tworld\r\n')
          '\'hello\\tworld\\r\\n\''))
    (case 'simple vec'
      (eq (src::serialize (vec 1 2 'three' 4 -5))
          '(vec 1 2 \'three\' 4 -5)'))
    (case 'nested vec'
      (eq (src::serialize (vec 'hi' 'hello' (vec 1 2.42 3.14 'four')))
          '(vec \'hi\' \'hello\' (vec 1 2.42000000 3.14000000 \'four\'))'))
    (case 'simple map'
      (eq (src::serialize (do (: m (map))
                            (map::set! m 'hi' 2)
                            (map::set! m 'hello' 5)
                            (map::set! m (vec 1 2) 'is vec')))
          '(do (: m (map)) (map::set! m \'hi\' 2) (map::set! m \'hello\' 5) (map::set! m (vec 1 2) \'is vec\'))'))
    (case 'stream'
      (eq (src::serialize (stream)) '(stream)'))))
